package cache

import (
	"fmt"
	"log"
	"os"
	"sync"

	"github.com/RohitAwate/OAuth2Bin/oauth2/utils"
	"github.com/gomodule/redigo/redis"
)

var pool redis.Pool

// NewConn returns a Redis connection.
// It is the responsibility of the receiver to close the connection.
func NewConn() redis.Conn {
	return pool.Get()
}

// CloseConn closes a Redis connection.
// Also captures the error, if any, and logs it.
func CloseConn(conn redis.Conn) {
	err := conn.Close()
	if err != nil {
		log.Println(err)
	}
}

// ClosePool closes the pool of Redis connections.
// Also captures the error, if any, and logs it.
func ClosePool() {
	utils.Clearln() // Remove the '^C' generated by SIGINT
	log.Println("Closing Redis pool")
	err := pool.Close()
	if err != nil {
		log.Println(err)
		return
	}

	log.Println("Redis pool closed")
}

var mut sync.Mutex

// Initializes a pool a connections with Redis.
// Based on certain environment variables, it decides which Redis
// server to connect to.
//
// If:
// - DOCKER is defined, connects to a Redis container.
// - REDIS_HOST, REDIS_PASS and REDIS_PORT are defined, connects to that server.
// - none of these are defined, connects to a local Redis server.
func init() {
	pool = redis.Pool{
		MaxActive: 30,
		MaxIdle:   10,
		Dial: func() (redis.Conn, error) {
			mut.Lock()
			defer mut.Unlock()

			var conn redis.Conn
			var err error

			if os.Getenv("DOCKER") != "" {
				// Uses the Redis container if running within Docker
				conn, err = redis.DialURL("redis://redis:6379")
				printRedisServer("Docker")
			} else if os.Getenv("REDIS_HOST") == "" && os.Getenv("REDIS_PASS") == "" && os.Getenv("REDIS_PORT") == "" {
				// Else defaults to a local Redis server
				conn, err = redis.Dial("tcp", ":6379")
				printRedisServer("Local")
			} else {
				addr := fmt.Sprintf("redis://:%s@%s:%s",
					os.Getenv("REDIS_PASS"), os.Getenv("REDIS_HOST"), os.Getenv("REDIS_PORT"))
				conn, err = redis.DialURL(addr)
				printRedisServer(os.Getenv("REDIS_HOST"))
			}

			if err != nil {
				// Panics if connection could not be established with a Redis server
				log.Fatal(err)
			}

			return conn, nil
		},
	}
}

var serverPrinted bool

// Prints out the Redis Server source. Dial may be called multiple times
// to create new connections throughout the runtime of the application.
// We are interested in knowing the source just once at server startup.
// Hence, this function.
func printRedisServer(server string) {
	if !serverPrinted {
		log.Println("Redis Server: " + server)
		serverPrinted = true
	}
}
