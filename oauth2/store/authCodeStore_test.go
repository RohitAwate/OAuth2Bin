package store

import (
	"fmt"
	"testing"
)

// TestAuthCodeFlow tests the entirety of the functions set of authCodeStore
// as they would be used by the Authorization Code flow
func TestAuthCodeFlow(t *testing.T) {
	// Generating an authorization grant which would
	// be generated after the user authorizes the client app.
	code := NewAuthCodeGrant()
	t.Logf("Generated authorization code grant: %s\n", code)

	// Generating a token based on the grant which would
	// be generated by invoking the token endpoint
	token, err := NewAuthCodeToken(code, "")
	if err != nil {
		t.Fatalf("Could not generate token:\n%s\n", err)
	}

	t.Logf("Token generated: %s\n", token.AccessToken)

	// Check if token exists
	res := VerifyAuthCodeToken(token.AccessToken)
	if !res {
		t.Fatalf("Auth Code token verification failed\n")
	}

	// Issue new token based on the previously issued refresh token
	token, err = NewAuthCodeRefreshToken(token.RefreshToken)
	if err != nil {
		t.Fatalf("Could not generate token from refresh token\n")
	}

	// Remove the token
	invalidateAuthCodeToken(token.AccessToken)
	t.Logf("Token invalidated\n")
}

var strLen = 16
var iterations = 1000
var generated []string

func TestGenerateNonce(t *testing.T) {
	generated = make([]string, iterations)

	for i := 0; i < iterations; i++ {
		t.Run(fmt.Sprintf("#%d", i), testGenerateNonceFunc(strLen, i))
	}
}

func testGenerateNonceFunc(n, i int) func(*testing.T) {
	return func(t *testing.T) {
		newStr := generateNonce(n)

		for j := 0; j < i; j++ {
			if generated[j] == newStr {
				t.Errorf("Duplicate string on attempt #%d", i)
			}
		}

		generated[i] = newStr
	}
}

func TestRefreshTokenExists(t *testing.T) {
	code := NewAuthCodeGrant()
	token, err := NewAuthCodeToken(code, "")
	if err != nil {
		t.Fatal(err)
	}

	exists := AuthCodeRefreshTokenExists(token.RefreshToken, true)

	if exists {
		t.Log("found refresh token")
	} else {
		removeAuthCodeGrant(code)
		t.Fatal("failed to find refresh token")
	}
}
